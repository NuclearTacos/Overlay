<!DOCTYPE html>
<html>
<!-- CSS only -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/css/bootstrap.min.css"
  rel="stylesheet" integrity="sha384-0evHe/X+R7YkIZDRvuzKMRqM+OrBnVFBL6DOitfPri4tjfHxaWutUpFmBp4vmVor"
  crossorigin="anonymous">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>



<style>
.overlay-container {
  align-items: center;
  justify-content: center;
  margin: auto;
  width: fit-content;
}

#container {
  width: 400px;
  height: 400px;
  position: relative;

  /*background: blue;*/
}

#animate {
  width: 50px;
  height: 50px;
  position: relative;
  background-color: red;
}
</style>
<body>

<div>
  <div class="bucket">
  </div>
</div>


<script>
// Helper Methods
function createGuid() {
   return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
   });
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function bucketRequest(bucketName, fileRoute){
  let blobUrl = JSON.parse( $.ajax({
    type: "GET",
    async: false,
    dataType: "application/json",
    url: 'https://storage.googleapis.com/storage/v1/b/'+bucketName+'/o/'+fileRoute
  }).responseText).mediaLink;

  let blobData = $.ajax({
      type: "GET",
      async: false,
      dataType: "application/json",
      url: blobUrl
    }).responseText;

  return blobData;
}
// end Helper Methods

// classes
class OverlayElement {
    get id(){
        return this._id;
    }

    get cardTemplate(){
        return this._cardTemplate;
    }

    get displayDuration(){
        return this._displayDuration;
    }

    async showCeremony(){
        const showCode = "{ let id = '"+this._id+"';"+this._showCeremony+" }";
        await setTimeout(showCode, 1);
        return;
    }

    async hideCeremony(){
        const hideCode = "{ let id = '"+this._id+"';"+this._removeCeremony+" }";
        await setTimeout(hideCode, 1);
        return;
    }

    updateTemplateId(){
        this._cardTemplate = $(this._cardTemplate).attr('id',this._id).prop('outerHTML');
    }

    constructor(jsonConfig) {
        this._id = createGuid();
        this._config = JSON.parse(jsonConfig);

        this._cardTemplate = this._config.cardTemplate;
        this._displayDuration = this._config.displayDuration;
        this._showCeremony = this._config.showCeremony;
        this._removeCeremony = this._config.removeCeremony;

        this.updateTemplateId();

        $('.bucket').append(this._cardTemplate);
    }
}
// endclasses

// cloudcommands
function uploadDatabase(dataObj){
  return $.ajax({
    type: "POST",
    async: false,
    dataType: "application/json",
    url: "https://upload-data-kwrdwjisqa-uc.a.run.app",
    data: JSON.stringify(dataObj)
  });
}

function readDatabase(){
  return bucketRequest('tf-overlays-db','data.json');
}

function postOverlaysCommand(command){
  let commandObject = {
    "id": createGuid(),
    "command": command
  }

  let cardData = $.ajax({
    type: "POST",
    async: false,
    dataType: "application/json",
    url: "https://write-command-kwrdwjisqa-uc.a.run.app",
    data: JSON.stringify(commandObject)
  }).responseText;
}


// todo: make this check against the Id of the last processed command.
function readOverlaysCommand(){
  return bucketRequest('tf-overlays-db','active-command.json');
}

// async function elementLifeCycle(){
//   let data = '{ "exCount": 0 }';
//   let cardData = $.ajax({
//     type: "POST",
//     async: false,
//     dataType: "application/json",
//     url: "https://read-environment-var-kwrdwjisqa-uc.a.run.app",
//     data: data
//   }).responseText;

//   {
//     await delay(1000);
//     let newElement = new OverlayElement(cardData);
//     newElement.showCeremony();
//     await delay(3000);
//     newElement.hideCeremony();
//   }
// }
// endcloudcommands

function getElementsData(gameName){
  let demoData = bucketRequest('tf-overlays-db','data.json');
  let responseObj = JSON.parse(demoData);

  return responseObj.games.filter( game => game.key == gameName )[0].data;
}

// command structure:
// game.dnd5e/spells.fire_bolt
function processCommand(commandObj){
    lastCommandId = commandObj.id;

    let data = JSON.parse(readDatabase());
    let propArray = commandObj.command.split('/');

    let currentObj = data;
    propArray.forEach(element => {
        let commandPropertyKey = element.split('.')[0];
        let commandPropertyValue = element.split('.')[1];

        currentObj = currentObj[commandPropertyKey].filter( comm => comm.key == commandPropertyValue )[0];
    });

    if( ''+currentObj.cardTemplate != '' ){
        return currentObj;
    }
}

function getElementTemplate(element){
  elemTemplate = bucketRequest(element.bucket, element.object);

  return elemTemplate;
}

function mergeSpellElement(spell,element){
  $('#'+element.id+' .ph-level').html(spell.damage_type);
  $('#'+element.id+' .ph-name').html(spell.name);
  $('#'+element.id+' .ph-description').html(spell.description);
}

let lastCommandId = '';

let commandQueue = [];

function enqueue(commandObj){
    commandQueue.push(commandObj);
    lastCommandId = commandObj.id;
}

function dequeue(){
    // dequeue will only be called once the array is not empty
    if( commandQueue != '' ){
        return commandQueue.splice(0,1)[0];
    }
    else{
        console.log("HEY!  dequeue() was called, and there were no items in the commandQueue");
        return null;
    }
}

async function executeCommand(commandObj){
    animationLocked = true;

    let element = processCommand(commandObj);
    let elementTemplate = getElementTemplate(element);

    let newElement = new OverlayElement(elementTemplate);
    mergeSpellElement(element, newElement);


    newElement.showCeremony();

    if( newElement.displayDuration != ''){
        // When a duration is set, display for the
        // duration before executing hideCeremony().
        let delayDur = newElement.displayDuration * 1000;
        delay(delayDur).then( () =>{
            newElement.hideCeremony();

            // The element was shown, and the delay has passed
            // Now, we set the clear method
            elemClearMethod = ( async() => {

                animationLocked = false;
                elemClearMethod = ( async() => {return null;} ); // reset this method once it has been consumed.
                return;
            });
        });
    }
    else{
        // When a duration isn't set, we need to unlock animations and set a clear method so
        elemClearMethod = ( async() => {
            // $(something).fadeOut() isn't _quite async_
            // async, so this doesn't quite work all the time....
            // Bummer

            await newElement.hideCeremony().then( () => {
                elemClearMethod = ( async() => {return null;} ); // reset this method once it has been consumed.
                animationLocked = false;
            });

            return;
        });
    }

    return newElement;
}

// async function waitForUnlock(){
//     while( animationLocked == true ){
//         await delay(500);
//     }
// }


let elemClearMethod = ( async() => {return null;} );

let animationLocked = false;
let queueLocked = false;



$(document).ready( function() {

    setInterval(() => {
        try{
            let commandObj = JSON.parse( readOverlaysCommand() );
            if( commandObj.id != lastCommandId && queueLocked == false ){
                queueLocked = true;
                enqueue( commandObj );

                // Calling this will make sure that, if the animation
                // has been completed, the active/persistent
                // element will be dismissed and then the lock will be cleared.
                elemClearMethod();
                queueLocked = false;
            }


            if( commandQueue != '' && animationLocked == false ){
                executeCommand(dequeue()).then( (newElement) => {
                    // This method will be defined in cases where the delay is finite.
                    // Running it immediately will allow the animation lock to be safely removed.
                    if( newElement.displayDuration != '' ){
                        elemClearMethod();
                    }
                });
            }
        }catch{}
    }, 500);
});

</script>

</body>
<!--
It might be better if you use a Markdown to HTML converter.
I recommend ShowdownJS. Just add it to your project with
<script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/1.9.0/showdown.min.js"></script>
-->
</html>
